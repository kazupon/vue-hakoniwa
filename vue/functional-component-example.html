<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <script src="../node_modules/vue/dist/vue.js"></script>
  </head>
  <body>
    <div id="app">
      <p>{{msg}}</p>
      <pre>{{$data}}</pre>
      <pre>{{$validation}}</pre>
      <validatable field="field1" validators="required">
        <input @valid="valid = $event" @focus="onFocus" type="text" v-model="msg">
      </validatable>
    </div>
    <script>
      const { bind, isPlainObject, noop, extend, resolveAsset } = Vue.util

      function getWatcher () {
        const vm = new Vue({ data: { a: 1 } })
        const unwatch = vm.$watch('a', function (a) {})
        const Watcher = vm._watchers[0].constructor
        unwatch()
        return Watcher
      }
      const Watcher = getWatcher() 

      function getDep () {
        return new Vue({ data: { a: 1 } })._data.__ob__.dep.constructor
      }
      const Dep = getDep()

      function makeComputedGetter (getter, owner) {
        const watcher = new Watcher(owner, getter, null, { lazy: true })
        return function computedGetter () {
          if (watcher.dirty) { watcher.evaluate() }
          if (Dep.target) { watcher.depend() }
          return watcher.value
        }
      }

      function required (val) {
        if (Array.isArray(val)) {
          if (val.length !== 0) {
            let valid = true
            for (let i = 0, l = val.length; i < l; i++) {
              valid = required(val[i])
              if (!valid) {
                break
              }
            }
            return valid
          } else {
            return false
          }
        } else if (typeof val === 'number' || typeof val === 'function') {
          return true
        } else if (typeof val === 'boolean') {
          return val
        } else if (typeof val === 'string') {
          return val.length > 0
        } else if (val !== null && typeof val === 'object') {
          return Object.keys(val).length > 0
        } else if (val === null || val === undefined) {
          return false
        }
      }

      const validators = { required }
      const assets = Object.create(null)
      extend(assets, validators)
      Vue.options.validators = assets

      const strats = Vue.config.optionMergeStrategies
      if (strats) {
        strats.validators = (parent, child) => {
          if (!child) { return parent }
          if (!parent) { return child }
          const ret = Object.create(null)
          extend(ret, parent)
          for (let key in child) {
            ret[key] = child[key]
          }
          return ret
        }
      }

      Vue.validator = (id, definition) => {
        if (!definition) {
          return Vue.options['validators'][id]
        } else {
          Vue.options['validators'][id] = definition
        }
      }

      class Validation {
        constructor (options = {}) {
          this.name = options.name
          this.groups = options.groups || []
          this.classes = options.classes || {}

          Vue.util.defineReactive(this, 'result', {})
        }

        set (key, val) {
          Vue.set(this.result, key, val)
        }

        get (key) {
          return this.result[key]
        }
      }

      Vue.mixin({ created: validationInit })

      function validationInit () {
        console.log('call validationInit', this)
        const options = this.$options
        const { validation } = options

        // validation instance injection
        if (validation) {
          this._validation = new Validation(validation)
        } else if (options.parent && options.parent._validation) {
          console.log('already parent instance!!')
          this._validation = options.parent._validation
        }

        // $validation computed property injection
        if (validation) {
          const validationName = typeof validation === 'string' ? validation : validation.name
          const computedDescriptor = {
            enumerable: true,
            configurable: true,
            set: noop,
            get: makeComputedGetter(function () { return this._validation.result }, this)
          }
          Object.defineProperty(this, `$${validationName}`, computedDescriptor)
        }
      }

      function getValidatorResult (name) {
        let ret = null
        if (this.results.length === 0) { return false }
        ret = false
        for (let i = 0; i < this.results.length; i++) {
          const result = this.results[i]
          if (result.name !== name) {
            continue
          } else {
            if (typeof result.value === 'boolean' && !result.value) {
              ret = true
              break
            }
            if (typeof result.value === 'string' && !result.value) {
              ret = result.value
              break
            }
          }
        }
        return ret
      }

      Vue.component('validate-control', {
        props: {
          field: {
            type: String,
            required: true
          },
          groups: {
            type: [String, Array],
            default: null
          },
          auto: {
            type: Boolean,
            default: true
          },
          validators: {
            type: [String, Array, Object],
            required: true
          },
          child: Object
        },
        data () {
          return {
            results: [],
            dirty: false,
            modified: false
          }
        },
        computed: {
          valid () {
            let ret = null;
            if (this.results.length === 0) { return true }
            ret = true
            for (let i = 0; i < this.results.length; i++) {
              const result = this.results[i]
              if (typeof result.value === 'boolean' && !result.value) {
                ret = false
                break
              }
              if (typeof result.value === 'string' && result.value) {
                ret = false
                break
              }
            }
            return ret
          },
          invalid () {
            return !this.valid
          },
          pristin () {
            return !this.dirty
          }
        },
        watch: {
          valid (val, old) {
            console.log('validate-control:watch#valid', val, old, this)
            if (val) {
              this.$emit('valid', val)
            } else {
              this.$emit('invalid')
            }
          },
          dirty (val, old) {
            console.log('validate-control:watch#dirty', val, old)
            if (val) {
              this.$emit('dirty')
            } else {
              this.$emit('pristin')
            }
          },
          modified (val, old) {
            console.log('validate-control:watch#modified', val, old)
            this.$emit('modified')
          }
        },
        // render component with the child element
        render (h) {
          this.child.host = this // set this component
          console.log('validate-control#render', this.child, this._vnode)
          return this.child
        },
        mounted () {
          this._value = this.$el.value
          this.$el.vm = this
          // TODO: must be keep the event handler, so need to destroy from DOM
          this.auto && this.$el.addEventListener('input', this.onInput)
          console.log('validate-control#mounted', this._value)
        },
        updated () {
          console.log('validate-control#updated', this._value)
        },
        destroyed () {
          this.auto && this.$el.removeEventListener('input', this.onInput)
        },
        methods: {
          onInput (e) {
            this.results = []

            const value = e.target.value
            if (!this.dirty && this._value !== value) {
              this.dirty = true
            }
            this.modified = this._value !== value

            // TODO: should be implmented async validation
            this.validators.forEach(name => {
              const validator = resolveAsset(this.$options, 'validators', name)
              const result = validator(value)
              if (!result) {
                this.results.push({ name: name, value: false })
              }
            })

            e.vm = this
            this.$emit('input', e)
          }
        }
      })

      Vue.component('validatable', {
        functional: true,
        props: {
          field: {
            type: String, required: true
          },
          groups: {
            type: [String, Array],
            default: null
          },
          auto: {
            type: Boolean,
            default: true
          },
          validators: {
            type: [String, Array, Object],
            required: true
          }
        },
        render (h, props, children) {
          console.log('validatable#render', props, children)
          const child = props.child = children[0]
          // setup event handler from event handlers of child
          const on = { valid: child.data.on.valid } 
          let validators = props.validators
          if (typeof validators === 'string') {
            validators = [validators]
          } else if (Array.isArray(props.validators)) {
            validators = props.validators
          } else if (Vue.util.isPlainObject(props.validators)) {
            validators = Object.keys(props.validators)
          }
          props.validators = validators

          // setup validate control component
          const comp = h('validate-control', { props, on })
          
          // setup dynamic computed properties
          // TODO: should be fixed duplicated definition
          const computed = comp.componentOptions.Ctor.options.computed || {}
          validators.forEach(validator => {
            computed[validator] = bind(() => {
              return bind(getValidatorResult, comp.child)(validator)
            }, comp.child)
          })

          return comp
        }
      })

      const vm = new Vue({
        data: {
          msg: 'hello',
          valid: 0,
          invalid: 0,
          dirty: 0,
          pristin: 0,
          modified: 0
        },
        validation: {
          name: 'validation',
          groups: [],
          classes: {}
        },
        methods: {
          onParentInput (e) {
            console.log('onParentInput', e)
          },
          onFocus (e) {
            console.log('onFocus', e)
          }
        }
      }).$mount('#app')
    </script>
  </body>
</html>
